# 員工績效系統與報工系統整合說明文件

## 1. 系統架構概述

### 1.1 整體架構
- 前端：React 應用程式 (PerformanceDashboard.js)
- 後端：報工系統 API (RunGuManagement/Controllers/KPIController.cs)
- 資料來源：報工系統資料庫

### 1.2 核心功能
1. 員工選擇與資料對應
2. 日期選擇（年/月/日）
3. 檢視模式切換（日/月度統計）
4. 九大績效指標卡片展示

## 2. 員工資料整合機制

### 2.1 員工資料獲取流程
```javascript
// 獲取員工列表
const loadEmployees = async () => {
  try {
    const response = await fetch(`${REPORT_API.BASE_URL}/AREditior/GetAllUserinfoByFilter`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        Keyword: "",
        Year: selectedYear.toString(),
        Month: selectedMonth.toString().padStart(2, '0')
      })
    });

    const data = await response.json();
    
    // 過濾並整理員工數據
    const uniqueEmployees = data.result
      .filter(emp => emp.user_name && emp.role_name)
      .map(emp => ({
        id: emp.user_name,           // 使用員工名稱作為唯一標識
        name: emp.user_name,         // 顯示名稱
        employee_name: emp.user_name, // 用於API查詢
        department: '技術部',        // 預設部門
        role: emp.role_name,         // 職位
        displayName: `${emp.user_name} (技術部 - ${emp.role_name})`
      }));

    setEmployees(uniqueEmployees);
  } catch (error) {
    console.error('獲取員工列表失敗:', error);
    // 使用預設員工列表作為後備
  }
};
```

### 2.2 員工資料對應原則
1. **識別方式**：使用員工姓名（user_name）作為主要識別依據
2. **資料對應**：前端選擇的員工名稱直接對應報工系統的 user_Name
3. **顯示格式**：`員工名稱 (部門 - 職位)`

## 3. 資料獲取與處理機制

### 3.1 資料獲取流程
```javascript
const loadEmployeeData = async (employeeId, targetYear, targetMonth, targetDay) => {
  // 同時獲取年度和月度數據
  const [yearResponse, monthResponse] = await Promise.all([
    fetch(`${REPORT_API.BASE_URL}${REPORT_API.ENDPOINTS.kpiOverviewYear}`, {
      method: 'POST',
      headers: REPORT_API.headers,
      body: JSON.stringify(targetYear)
    }),
    fetch(`${REPORT_API.BASE_URL}${REPORT_API.ENDPOINTS.kpiOverviewMonth}`, {
      method: 'POST',
      headers: REPORT_API.headers,
      body: JSON.stringify({
        Year: targetYear,
        Month: targetMonth,
        Day: targetDay
      })
    })
  ]);
  
  const [yearData, monthData] = await Promise.all([
    yearResponse.json(),
    monthResponse.json()
  ]);
}
```

### 3.2 資料處理邏輯
#### 3.2.1 每日統計模式
```javascript
// 每日統計模式
employeeData = monthData.result.find(item => 
  item.user_Name === employeeId && 
  item.work_Day === `${targetYear}-${String(targetMonth).padStart(2, '0')}-${String(targetDay).padStart(2, '0')}T00:00:00`
);
```

#### 3.2.2 月度統計模式
```javascript
// 月度統計模式
const targetMonthStr = `${targetYear}-${String(targetMonth).padStart(2, '0')}-01T00:00:00`;

// 找出該月份的數據
const targetMonthData = employeeYearData.filter(item => 
  item.work_Month === targetMonthStr
);

if (targetMonthData.length > 0) {
  // 優先選擇有實際數據的記錄
  const validData = targetMonthData.find(data => 
    data.completion_Rate !== null || 
    data.total_Hours > 0 || 
    data.cnt_Done > 0
  );

  // 使用找到的數據，確保work_Month是正確的月份
  const selectedData = validData || targetMonthData[0];
  
  employeeData = {
    ...selectedData,
    work_Month: targetMonthStr,
    completion_Rate: selectedData.completion_Rate || 0,
    yield_Percent: selectedData.yield_Percent || 0,
    total_Hours: selectedData.total_Hours || 0,
    machine_Run_Hours: selectedData.machine_Run_Hours || 0,
    maintenance_Count: selectedData.maintenance_Count || 0,
    otd_Rate: selectedData.otd_Rate || 0,
    kpi_Percent: selectedData.kpi_Percent || 0,
    units_Per_Hour: selectedData.units_Per_Hour || 0,
    attendance: 100
  };
}
```

## 4. 績效指標計算與展示

### 4.1 九大績效指標
1. 工作完成量 (completion_Rate)
2. 產品質量 (yield_Percent)
3. 工作時間 (total_Hours)
4. 差勤紀錄 (attendance)
5. 機台運行狀態 (machine_Run_Hours)
6. 機台維護紀錄 (maintenance_Count)
7. 目標達成率 (otd_Rate)
8. 關鍵績效指標 (kpi_Percent)
9. 效率指標 (units_Per_Hour)

### 4.2 指標數據處理
```javascript
const metrics = [
  {
    id: "workCompletion",
    title: "工作完成量",
    value: (data) => data?.completion_Rate ? Math.round(data.completion_Rate * 100) : 0,
    unit: "%",
    icon: <Activity className="w-6 h-6" />,
    color: "text-blue-500",
    target: 95,
  },
  // ... 其他指標配置
];
```

## 5. 資料更新機制

### 5.1 切換月份
```javascript
onChange={async (e) => {
  const newMonth = parseInt(e.target.value);
  
  // 先清空數據
  setEmployeeData(null);
  
  // 更新月份
  setSelectedMonth(newMonth);
  
  // 等待狀態更新
  await new Promise(resolve => setTimeout(resolve, 0));
  
  // 重新加載數據
  await loadEmployeeData(
    selectedEmployee,
    selectedYear,
    newMonth,
    selectedDay
  );
}}
```

### 5.2 切換檢視模式
```javascript
onChange={async (e) => {
  const isDaily = e.target.value === "daily";
  const newDay = isDaily ? 1 : null;
  
  // 先清空數據
  setEmployeeData(null);
  
  // 更新檢視方式
  setSelectedDay(newDay);
  
  // 等待狀態更新
  await new Promise(resolve => setTimeout(resolve, 0));
  
  // 重新加載數據
  await loadEmployeeData(
    selectedEmployee,
    selectedYear,
    selectedMonth,
    newDay
  );
}}
```

## 6. 錯誤處理機制

### 6.1 資料載入錯誤處理
```javascript
try {
  // 資料載入邏輯
} catch (error) {
  console.error('載入KPI資料失敗:', error);
  // 使用預設數據
  setEmployeeData({
    completion_Rate: 0,
    yield_Percent: 0,
    total_Hours: 0,
    machine_Run_Hours: 0,
    maintenance_Count: 0,
    otd_Rate: 0,
    kpi_Percent: 0,
    units_Per_Hour: 0,
    attendance: 0
  });
}
```

### 6.2 空值處理
- 所有數值型指標預設為 0
- 使用可選鏈運算符 (?.) 處理可能為 null 的物件
- 使用邏輯或運算符 (||) 提供預設值

## 7. 效能優化

### 7.1 資料載入優化
1. 使用 Promise.all 並行請求年度和月度數據
2. 實作資料快取機制
3. 使用防抖處理頻繁的資料請求

### 7.2 渲染優化
1. 使用 React.memo 優化組件重渲染
2. 實作虛擬滾動優化長列表
3. 使用 useMemo 和 useCallback 優化計算密集型操作

## 8. 後續優化建議

1. 實作資料快取機制，減少重複請求
2. 添加錯誤重試機制
3. 優化資料載入狀態的視覺反饋
4. 實作資料預加載機制
5. 添加更詳細的錯誤日誌
6. 優化資料格式化邏輯
7. 實作離線模式支援

## 9. 注意事項

1. 員工名稱必須完全匹配報工系統資料庫中的名稱
2. 日期格式統一使用 ISO 格式 (YYYY-MM-DDT00:00:00)
3. 所有數值型指標都需要處理 null/undefined 情況
4. 確保時區設定正確
5. 注意資料更新時的狀態同步
